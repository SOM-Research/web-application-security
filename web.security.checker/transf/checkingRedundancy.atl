-- @path ANO=/webApplicationSecurity/metamodels/anomalies.ecore
-- @path PSM=/webApplicationSecurity/metamodels/ServletSecurity.ecore

module checkingRedundancy;
create OUT : ANO from IN : PSM;

helper def : ALL_SECURITY_CONSTRAINTS : Sequence(PSM!SecurityConstraint) = 
	PSM!SecurityConstraint.allInstances();

helper context PSM!SecurityConstraint def : getSecurityConstraintPos : Integer =
	thisModule.ALL_SECURITY_CONSTRAINTS->indexOf(self);

helper context PSM!SecurityConstraint def : getRedundantConstraints : Sequence(PSM!SecurityConstraint) =
	let webResource_urlPatternMatch : Sequence(PSM!SecurityConstraint) = thisModule.ALL_SECURITY_CONSTRAINTS->reject(sc | sc = self)
										->collect(sc | sc.webResourceCollection)->flatten()
											->select(wrc | wrc.urlPattern->exists(up | self.webResourceCollection->exists(swrc | swrc.urlPattern->exists(sup | sup.value = up.value))))
												->asSet() in
	let webResource_httpMethodMatch : Sequence(PSM!SecurityConstraint) = thisModule.ALL_SECURITY_CONSTRAINTS->reject(sc | sc = self)
										->collect(sc | sc.webResourceCollection)->flatten()
											->select(wrc | wrc.httpMethod->exists(hm | self.webResourceCollection->exists(swrc | swrc.httpMethod->exists(shm | shm.name = hm.name and shm.omission = hm.omission)))) 
												->asSet() in
	let securityConstraint_roleMatch : Sequence(PSM!SecurityConstraint) = thisModule.ALL_SECURITY_CONSTRAINTS->reject(sc | sc = self)
											->collect(sc | sc.authConstraint)
												->select(ac | ac.roleName->exists(rn | self.authConstraint.roleName->exists(srn | srn.name = rn.name))) 
													->collect(wr | wr.refImmediateComposite())->asSet() in
	let intersectionWebResource : Sequence(PSM!SecurityConstraint) = webResource_urlPatternMatch->intersection(webResource_httpMethodMatch)->collect(wr | wr.refImmediateComposite())->asSet() in
	let intersectionSecConstraints : Sequence(PSM!SecurityConstraint) = intersectionWebResource->intersection(securityConstraint_roleMatch) in
	intersectionSecConstraints->asSequence();
													
helper context PSM!SecurityConstraint def : isRedundant : Boolean =
	not self.getRedundantConstraints->isEmpty();

rule SecurityConstraint2ConstraintRedundancy {
	from
		s: PSM!SecurityConstraint (s.isRedundant)
	to
		t: ANO!ConstraintRedundancy (
			description <- 'Redundancy between security constraints ' + s.getSecurityConstraintPos.toString() + 
							' and ' + s.getRedundantConstraints->collect(rc | rc.getSecurityConstraintPos)->iterate(rc ; output : String = '' | output->concat(rc.toString() + ', ')).regexReplaceAll(', $', '') 
		)
	do {
		t.trace <- Sequence{s, s.getRedundantConstraints};
	}
}
